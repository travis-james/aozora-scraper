// DownloadWorks takes a directory name, such as "works" then iterates through
// a map of links (ml). On each link, it downloads the file and saves it to the
// provided dn.
func DownloadWorks(dn string, ml map[string]string) error {
	for key, val := range ml {
		// Get the response from a single work's link.
		resp, err := http.Get(val)
		if err != nil {
			return err
		}
		defer resp.Body.Close()

		// Then on that web page, find the link to the zip of the work.
		zl := GetZipLink(resp.Body, val)
		fn := dn + "/" + key + ".zip"
		err = DownloadFile(fn, zl)
		if err != nil {
			return err
		}
	}
	return nil
}

// ""Concurrent"""
func DownloadWorks(dn string, ml map[string]string) error {
	c := make(chan error)
	for key, val := range ml {
		cherr := <- go func(c chan error) {
			// Get the response from a single work's link.
			resp, err := http.Get(val)
			if err != nil {
				c <- err
			}
			defer resp.Body.Close()

			// Then on that web page, find the link to the zip of the work.
			zl := GetZipLink(resp.Body, val)
			fn := dn + "/" + key + ".zip"
			err = DownloadFile(fn, zl)
			if err != nil {
				c <- err
			}

		}(c)
		if cherr != nil {
			close(c)
			return cherr
		}
	}
	return nil
}



// DownloadWorks takes a directory name, such as "works" then iterates through
// a map of links (ml). On each link, it downloads the file and saves it to the
// provided dn.
func DownloadWorks(dn string, ml map[string]string) error {
	for key, val := range ml {
		// Get the response from a single work's link.
		resp, err := http.Get(val)
		if err != nil {
			return err
		}
		defer resp.Body.Close()

		// Then on that web page, find the link to the zip of the work.
		zl := GetZipLink(resp.Body, val)
		fn := dn + "/" + key + ".zip"
		err = DownloadFile(fn, zl)
		if err != nil {
			return err
		}
	}
	return nil
}